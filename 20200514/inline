{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%pylab inline\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from scipy.interpolate import interp1d\n",
    "from multiprocessing import Pool\n",
    "from functools import partial \n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "np.printoptions(precision=2)\n",
    "\n",
    "# time line\n",
    "T_min = 15\n",
    "T_max = 80\n",
    "T_y = 65\n",
    "\n",
    "# States of the economy, GOOD or BAD, {1 : GOOD}, {0 : BAD}\n",
    "S = [0,1]\n",
    "# All the money amount are denoted in thousand dollars\n",
    "earningShock = [0.9,1.1]\n",
    "# Define transition matrix of economical states\n",
    "# GOOD -> GOOD 0.8, BAD -> BAD 0.4 \n",
    "P = np.array([[0.4, 0.6],[0.2, 0.8]])\n",
    "# current risk free interest rate \n",
    "r_f = [0.01 ,0.03]\n",
    "# stock return depends on current and future econ states\n",
    "def r_m(current_state, next_state):\n",
    "    if (current_state == 1 and next_state == 1):\n",
    "        return 0.25\n",
    "    elif (current_state == 1 and next_state == 0):\n",
    "        return -0.05\n",
    "    elif (current_state == 0 and next_state == 1):\n",
    "        return 0.2\n",
    "    else:\n",
    "        return -0.1\n",
    "    \n",
    "#Define the utility function\n",
    "def u(c):\n",
    "    return np.log(c)\n",
    "        \n",
    "\n",
    "# Define deterministic function to captures the hump shape of life-cycle earnings.\n",
    "ageTick = [15, 25, 35, 45, 55, 80]\n",
    "earning = [35, 54, 67, 71, 60, 37]\n",
    "linearFit = interp1d(ageTick, earning, kind = \"quadratic\")\n",
    "detEarning = np.array(linearFit(np.linspace(15,80,66)))\n",
    "\n",
    "def y(age, s):\n",
    "    return detEarning[age-T_min] * earningShock[s]\n",
    "\n",
    "# Define the transtiion of state \n",
    "def transition(Z, a):\n",
    "    '''\n",
    "        Input: Z is a tuple containing states variables: (w, s) which is the current wealth and econ state\n",
    "               a is the action taken with contains variables: (c, b, k) which is the combination of consumption, bond and stock\n",
    "        Output: the next possible states with corresponding probabilities\n",
    "    '''\n",
    "    w, s = Z\n",
    "    c, b, k = a\n",
    "    # collect possible next state (w_next, s_next) with probability prob\n",
    "    Z_next = []\n",
    "    prob = []\n",
    "    # depend on the current econ state s and future state s_next we have the following return on bond and stock \n",
    "    for s_next in S:\n",
    "        r_bond = r_f[s]\n",
    "        r_stock = r_m(s,s_next)\n",
    "        w_next = b*(1+r_bond) + k*(1+r_stock)\n",
    "        Z_next.append([w_next, s_next])\n",
    "        prob.append(P[s, s_next])\n",
    "    return Z_next, prob"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# timeline is from age 15 - 80, use approximation for value function from age 15 - 79 by discretizing the state space\n",
    "# since we know the terminal condition. Here XX is the grid point collection. Initiate the grid and corresponding value.\n",
    "\n",
    "# This function is used to generate power grid \n",
    "def powspace(start, stop, power, num):\n",
    "    start = np.power(start, 1/float(power))\n",
    "    stop = np.power(stop, 1/float(power))\n",
    "    return np.power(np.linspace(start, stop, num=num), power) \n",
    "\n",
    "w_grid_size = 1000\n",
    "w_lower = 0\n",
    "w_upper = 1000\n",
    "T = T_max - T_min\n",
    "# wgrid = powspace(w_lower, w_upper, 3, num = w_grid_size)\n",
    "wgrid = np.linspace(w_lower, w_upper, num = w_grid_size)\n",
    "\n",
    "print(\"Shape of grid w grid: \", wgrid.shape)\n",
    "# V use to store the value \n",
    "V_t = np.zeros((w_grid_size,len(S),T))\n",
    "C_t = np.zeros((w_grid_size,len(S),T))\n",
    "B_t = np.zeros((w_grid_size,len(S),T))\n",
    "K_t = np.zeros((w_grid_size,len(S),T))\n",
    "print(\"Shape of Value matrix: \", V_t.shape)\n",
    "\n",
    "# Calculate terminal value function \n",
    "V_t[:, 0, T-1] = u(y(T_max,0) + wgrid)\n",
    "V_t[:, 1, T-1] = u(y(T_max,1) + wgrid)\n",
    "C_t[:, 0, T-1] = y(T_max,0) + wgrid\n",
    "C_t[:, 1, T-1] = y(T_max,1) + wgrid\n",
    "B_t[:, 0, T-1] = 0\n",
    "B_t[:, 1, T-1] = 0\n",
    "K_t[:, 0, T-1] = 0\n",
    "K_t[:, 1, T-1] = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "from scipy.optimize import minimize\n",
    "# Definition of the value function, return of the funciton is the value of the function and the coresponding policy\n",
    "def V(w, s, t, model):\n",
    "    beta = 0.98\n",
    "    def obj(bk):\n",
    "        b, k = bk\n",
    "        c = y(t,s) + w - b - k\n",
    "        if c <= 0 or b <= 0 or k <= 0:\n",
    "            return 999999999999 \n",
    "        Z_next, prob = transition([w,s], (c, b, k))\n",
    "        V_next = np.array([model[z[1]](z[0]) for z in Z_next])\n",
    "        return -(u(c) + beta * np.dot(V_next, prob))\n",
    "    res = minimize(obj, [5,5])\n",
    "    return np.array([-res.fun, res.x])\n",
    "\n",
    "# Smooth function is used to smooth out the nan values \n",
    "def smooth(array):\n",
    "    index = np.append(argwhere(np.isnan(array)),argwhere(np.isinf(array)))\n",
    "    n = len(array)\n",
    "    for i in index:\n",
    "        if i == 0:\n",
    "            array[i] = array[i+1]\n",
    "        elif i == n - 1:\n",
    "            array[i] = array[i-1]\n",
    "        else:\n",
    "            array[i] = (array[i-1] + array[i+1])/2\n",
    "    return array"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set value to the grid by backward induction \n",
    "pool = Pool()\n",
    "\n",
    "\n",
    "for t in range(T_max-2, T_min-1, -1):\n",
    "    print(t)\n",
    "    tt = t-T_min\n",
    "    cs = [interp1d(wgrid, smooth(V_t[:,0,tt+1]), kind = \"nearest\", fill_value=\"extrapolate\"),\n",
    "          interp1d(wgrid, smooth(V_t[:,1,tt+1]), kind = \"nearest\", fill_value=\"extrapolate\")]    \n",
    "    for s in S:                                               \n",
    "        f = partial(V, s = s, t = t, model = cs)\n",
    "        results = np.array(pool.map(f, wgrid))\n",
    "        V_t[:,s,tt] = results[:,0]\n",
    "        B_t[:,s,tt] = np.array([b[0] for b in results[:,1]])\n",
    "        K_t[:,s,tt] = np.array([k[1] for k in results[:,1]])\n",
    "        C_t[:,s,tt] = wgrid + y(t,s) - B_t[:,s,tt] - K_t[:,s,tt]\n",
    "pool.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(V_t[:,:, 64])"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
