{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%pylab inline\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from scipy.interpolate import interp2d\n",
    "from multiprocessing import Pool\n",
    "from functools import partial \n",
    "from pyswarm import pso\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "np.printoptions(precision=2)\n",
    "# time line\n",
    "T_min = 0\n",
    "T_max = 70\n",
    "T_R = 45\n",
    "beta = 1/(1+0.02)\n",
    "# All the money amount are denoted in thousand dollars\n",
    "earningShock = [0.8,1.2]\n",
    "# Define transition matrix of economical states\n",
    "# GOOD -> GOOD 0.8, BAD -> BAD 0.6 \n",
    "Ps = np.array([[0.6, 0.4],[0.2, 0.8]])\n",
    "# current risk free interest rate \n",
    "r_f = np.array([0.01 ,0.03])\n",
    "# stock return depends on current and future econ states\n",
    "r_m = np.array([[-0.2, 0.15],[-0.15, 0.2]])\n",
    "# probability of survival\n",
    "Pa = np.load(\"prob.npy\")\n",
    "# probability of employment transition \n",
    "Pe = np.array([[[[0.3, 0.7], [0.1, 0.9]], [[0.25, 0.75], [0.05, 0.95]]],\n",
    "               [[[0.25, 0.75], [0.05, 0.95]], [[0.2, 0.8], [0.01, 0.99]]]])\n",
    "# deterministic income\n",
    "detEarning = np.load(\"detEarning.npy\")\n",
    "# tax rate \n",
    "tau_L = 0.2\n",
    "tau_R = 0.1\n",
    "# minimum consumption\n",
    "c_bar = 3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Define the utility function\n",
    "def u(c):\n",
    "    gamma = 2\n",
    "    return (np.float_power(max(c-c_bar,0),1-gamma) - 1)/(1 - gamma)\n",
    "\n",
    "#Define the bequeath function, which is a function of wealth \n",
    "def uB(w):\n",
    "    B = 2\n",
    "    return B*u(w)\n",
    "\n",
    "#Define the earning function \n",
    "def y(t, x):\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return 0\n",
    "    else:\n",
    "        if t <= T_R:\n",
    "            return detEarning[t] * earningShock[int(s)] * e + (1-e)*5\n",
    "        else:\n",
    "            return detEarning[t]\n",
    "\n",
    "# Define the reward funtion\n",
    "def R(x, a):\n",
    "    c, b, k = a\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return uB(w+n)\n",
    "    else:\n",
    "        return u(c)\n",
    "\n",
    "# Define the transtiion of state (test)\n",
    "def transition(x, a, t):\n",
    "    '''\n",
    "        Input: x current state: (w, n, e, s, A) \n",
    "               a action taken: (c, b, k)\n",
    "        Output: the next possible states with corresponding probabilities\n",
    "    '''\n",
    "    # expected return on stock market \n",
    "    r_bar = 0.0667\n",
    "    c, b, k = a\n",
    "    w, n, s, e, A = x\n",
    "    \n",
    "    x_next = []\n",
    "    prob_next = []\n",
    "    # Agent is dead \n",
    "    if A == 0:\n",
    "        for s_next in [0, 1]:\n",
    "            x_next.append([0, 0, s_next, 0, 0])\n",
    "        return np.array(x_next), Ps[int(s)]\n",
    "    else:\n",
    "        # A = 1, agent is still alive and for the next period\n",
    "        Pat = [1-Pa[t], Pa[t]]\n",
    "        r_bond = r_f[int(s)]\n",
    "        for s_next in [0, 1]:\n",
    "            r_stock = r_m[int(s), s_next]\n",
    "            w_next =  b*(1+r_bond) + k*(1+r_stock)\n",
    "            if t < T_R:\n",
    "                # before retirement agents put 5% of income to 401k\n",
    "                n_next = (n+0.05*y(t,x))(1+r_stock)\n",
    "            else:\n",
    "                # after retirement calculate the annuity payment\n",
    "                N = np.sum(Pa[t:])\n",
    "                discounting = ((1+r_bar)**N - 1)/(r_bar*(1+r_bar)**N)\n",
    "                n_next = (n-n/discounting)(1+r_stock)\n",
    "            for e_next in [0,1]:\n",
    "                for A_next in [0,1]:\n",
    "                    # Age reaches 65 or agent is dead directly results in unemployment\n",
    "                    if t > T_R or A_next == 0:\n",
    "                        x_next.append([w_next, n_next, s_next, 0, A_next])\n",
    "                    else:\n",
    "                        x_next.append([w_next, n_next, s_next, e_next, A_next])\n",
    "                    prob_next.append(Ps[int(s)][s_next] * Pat[A_next] * Pe[int(s),s_next,int(e),e_next])\n",
    "        return np.array(x_next), np.array(prob_next) \n",
    "    \n",
    "# Value function is a function of state and time t\n",
    "def V(x, t, Vmodel):\n",
    "    # Define the objective function as a function of action\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return np.array([R(x,[0,0,0]),[0,0,0]])\n",
    "    else: \n",
    "        N = np.sum(Pa[t:])\n",
    "        discounting = ((1+r_bar)**N - 1)/(r_bar*(1+r_bar)**N)\n",
    "        def obj(bkTheta):\n",
    "            bk,theta = bkTheta\n",
    "            b = bk * theta\n",
    "            k = bk * (1-theta)\n",
    "            if t < T_R:\n",
    "                c = (1-tau_L)*(y(t, x) * (1-0.05)) + w - bk\n",
    "            else:\n",
    "                c = (1-tau_R)*y(t, x) + w + n/discounting - bk\n",
    "            if c <= c_bar:\n",
    "                return 9999999999\n",
    "            a = (c,b,k)\n",
    "            x_next, prob_next = transition(x, a, t)\n",
    "            return -(R(x, a) + beta * np.dot(Vmodel[int(s)][int(e)][int(A)](x_next[:,0], x_next[:,1]), prob_next))\n",
    "\n",
    "        if t < T_R:\n",
    "            ub = [(1-tau_L)*(y(t, x) * (1-0.05)) + w, 1]\n",
    "        else:\n",
    "            ub = [(1-tau_R)*y(t, x) + w + n/discounting, 1]\n",
    "        lb = [0, 0]\n",
    "        xopt, fopt = pso(obj, lb, ub)\n",
    "        max_val = -fopt\n",
    "        bk_m, theta_m = xopt\n",
    "        b_m = bk_m * theta_m\n",
    "        k_m = bk_m * (1-theta_m)\n",
    "        if t < T_R:\n",
    "            c_m = (1-tau_L)*(y(t, x) * (1-0.05)) + w - bk_m\n",
    "        else:\n",
    "            c_m = (1-tau_R)*y(t, x) + w + n/discounting - bk_m\n",
    "        return np.array([max_val, [c_m, b_m, k_m]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# wealth discretization \n",
    "w_grid_size = 100\n",
    "w_lower = 5\n",
    "w_upper = 20000\n",
    "# 401k amount discretization \n",
    "n_grid_size = 50\n",
    "n_lower = 5\n",
    "n_upper = 1000\n",
    "\n",
    "def powspace(start, stop, power, num):\n",
    "    start = np.power(start, 1/float(power))\n",
    "    stop = np.power(stop, 1/float(power))\n",
    "    return np.power( np.linspace(start, stop, num=num), power)\n",
    "\n",
    "# initialize the state discretization \n",
    "x_T = np.array([[w,n,e,s,0]   for w in powspace(w_lower, w_upper, 3, w_grid_size)\n",
    "                            for n in powspace(n_lower, n_upper, 3, n_grid_size)\n",
    "                            for s in [0,1]\n",
    "                            for e in [0,1]\n",
    "                            for A in [0,1]]).reshape((w_grid_size, n_grid_size, 2,2,2,5))\n",
    "\n",
    "xgrid = np.array([[w,n,e,s,A] for w in powspace(w_lower, w_upper, 3, w_grid_size)\n",
    "                            for n in powspace(n_lower, n_upper, 3, n_grid_size)\n",
    "                            for s in [0,1]\n",
    "                            for e in [0,1]\n",
    "                            for A in [0,1]]).reshape((w_grid_size, n_grid_size, 2,2,2,5))\n",
    "\n",
    "Vgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "cgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "bgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "kgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "\n",
    "# apply function to state space, need to reshape the matrix and shape it back to the size\n",
    "def applyFunToCalculateValue(fun, x = xgrid):\n",
    "    return np.array(list(map(fun, x.reshape((w_grid_size * n_grid_size * 2 * 2 * 2, 5))))).reshape((w_grid_size, n_grid_size, 2,2,2))\n",
    "\n",
    "Vgrid[:,:,:,:,:, T_max] = applyFunToCalculateValue(partial(R, a = [0,0,0]), x = x_T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time \n",
    "ws = xgrid[:,:,1,1,1,0].flatten()\n",
    "ns = xgrid[:,:,1,1,1,1].flatten()\n",
    "\n",
    "xs = xgrid.reshape((w_grid_size * n_grid_size * 2 * 2 * 2, 5))\n",
    "\n",
    "pool = Pool()\n",
    "\n",
    "for t in range(T_max-1, T_max-5, -1):\n",
    "    print(t)\n",
    "    cs = [[[np.vectorize(interp2d(ws, ns, Vgrid[:,:,s,e,A,t+1].flatten(),kind='cubic'))\n",
    "            for A in [0,1]] for e in [0,1]] for s in [0,1]]\n",
    "    f = partial(V, t = t, Vmodel = cs)\n",
    "    results = np.array(pool.map(f, xs))\n",
    "    \n",
    "    Vgrid[:,:,:,:,:,t] = results[:,0].reshape((w_grid_size,n_grid_size, 2,2,2))\n",
    "    plt.plot_surface(ws, ns, Vgrid[:,:,1,1,1,t])\n",
    "    plt.show()\n",
    "    cgrid[:,:,:,:,:,t] = np.array([r[0] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "    bgrid[:,:,:,:,:,t] = np.array([r[1] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "    kgrid[:,:,:,:,:,t] = np.array([r[2] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "pool.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "%pylab inline\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from scipy.interpolate import interp2d\n",
    "from multiprocessing import Pool\n",
    "from functools import partial \n",
    "from pyswarm import pso\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "np.printoptions(precision=2)\n",
    "# time line\n",
    "T_min = 0\n",
    "T_max = 70\n",
    "T_R = 45\n",
    "beta = 1/(1+0.02)\n",
    "# All the money amount are denoted in thousand dollars\n",
    "earningShock = [0.8,1.2]\n",
    "# Define transition matrix of economical states\n",
    "# GOOD -> GOOD 0.8, BAD -> BAD 0.6 \n",
    "Ps = np.array([[0.6, 0.4],[0.2, 0.8]])\n",
    "# current risk free interest rate \n",
    "r_f = np.array([0.01 ,0.03])\n",
    "# stock return depends on current and future econ states\n",
    "r_m = np.array([[-0.2, 0.15],[-0.15, 0.2]])\n",
    "# expected return on stock market \n",
    "r_bar = 0.0667\n",
    "# probability of survival\n",
    "Pa = np.load(\"prob.npy\")\n",
    "# probability of employment transition \n",
    "Pe = np.array([[[[0.3, 0.7], [0.1, 0.9]], [[0.25, 0.75], [0.05, 0.95]]],\n",
    "               [[[0.25, 0.75], [0.05, 0.95]], [[0.2, 0.8], [0.01, 0.99]]]])\n",
    "# deterministic income\n",
    "detEarning = np.load(\"detEarning.npy\")\n",
    "# tax rate \n",
    "tau_L = 0.2\n",
    "tau_R = 0.1\n",
    "# minimum consumption\n",
    "c_bar = 3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Define the utility function\n",
    "def u(c):\n",
    "    gamma = 2\n",
    "    return (np.float_power(max(c-c_bar,0),1-gamma) - 1)/(1 - gamma)\n",
    "\n",
    "#Define the bequeath function, which is a function of wealth \n",
    "def uB(w):\n",
    "    B = 2\n",
    "    return B*u(w)\n",
    "\n",
    "#Define the earning function \n",
    "def y(t, x):\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return 0\n",
    "    else:\n",
    "        if t <= T_R:\n",
    "            return detEarning[t] * earningShock[int(s)] * e + (1-e)*5\n",
    "        else:\n",
    "            return detEarning[t]\n",
    "\n",
    "# Define the reward funtion\n",
    "def R(x, a):\n",
    "    c, b, k = a\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return uB(w+n)\n",
    "    else:\n",
    "        return u(c)\n",
    "\n",
    "# Define the transtiion of state (test)\n",
    "def transition(x, a, t):\n",
    "    '''\n",
    "        Input: x current state: (w, n, e, s, A) \n",
    "               a action taken: (c, b, k)\n",
    "        Output: the next possible states with corresponding probabilities\n",
    "    '''\n",
    "    c, b, k = a\n",
    "    w, n, s, e, A = x\n",
    "    \n",
    "    x_next = []\n",
    "    prob_next = []\n",
    "    # Agent is dead \n",
    "    if A == 0:\n",
    "        for s_next in [0, 1]:\n",
    "            x_next.append([0, 0, s_next, 0, 0])\n",
    "        return np.array(x_next), Ps[int(s)]\n",
    "    else:\n",
    "        # A = 1, agent is still alive and for the next period\n",
    "        Pat = [1-Pa[t], Pa[t]]\n",
    "        r_bond = r_f[int(s)]\n",
    "        for s_next in [0, 1]:\n",
    "            r_stock = r_m[int(s), s_next]\n",
    "            w_next =  b*(1+r_bond) + k*(1+r_stock)\n",
    "            if t < T_R:\n",
    "                # before retirement agents put 5% of income to 401k\n",
    "                n_next = (n+0.05*y(t,x))(1+r_stock)\n",
    "            else:\n",
    "                # after retirement calculate the annuity payment\n",
    "                N = np.sum(Pa[t:])\n",
    "                discounting = ((1+r_bar)**N - 1)/(r_bar*(1+r_bar)**N)\n",
    "                n_next = (n-n/discounting)(1+r_stock)\n",
    "            for e_next in [0,1]:\n",
    "                for A_next in [0,1]:\n",
    "                    # Age reaches 65 or agent is dead directly results in unemployment\n",
    "                    if t > T_R or A_next == 0:\n",
    "                        x_next.append([w_next, n_next, s_next, 0, A_next])\n",
    "                    else:\n",
    "                        x_next.append([w_next, n_next, s_next, e_next, A_next])\n",
    "                    prob_next.append(Ps[int(s)][s_next] * Pat[A_next] * Pe[int(s),s_next,int(e),e_next])\n",
    "        return np.array(x_next), np.array(prob_next) \n",
    "    \n",
    "# Value function is a function of state and time t\n",
    "def V(x, t, Vmodel):\n",
    "    # Define the objective function as a function of action\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return np.array([R(x,[0,0,0]),[0,0,0]])\n",
    "    else: \n",
    "        N = np.sum(Pa[t:])\n",
    "        discounting = ((1+r_bar)**N - 1)/(r_bar*(1+r_bar)**N)\n",
    "        def obj(bkTheta):\n",
    "            bk,theta = bkTheta\n",
    "            b = bk * theta\n",
    "            k = bk * (1-theta)\n",
    "            if t < T_R:\n",
    "                c = (1-tau_L)*(y(t, x) * (1-0.05)) + w - bk\n",
    "            else:\n",
    "                c = (1-tau_R)*y(t, x) + w + n/discounting - bk\n",
    "            if c <= c_bar:\n",
    "                return 9999999999\n",
    "            a = (c,b,k)\n",
    "            x_next, prob_next = transition(x, a, t)\n",
    "            return -(R(x, a) + beta * np.dot(Vmodel[int(s)][int(e)][int(A)](x_next[:,0], x_next[:,1]), prob_next))\n",
    "\n",
    "        if t < T_R:\n",
    "            ub = [(1-tau_L)*(y(t, x) * (1-0.05)) + w, 1]\n",
    "        else:\n",
    "            ub = [(1-tau_R)*y(t, x) + w + n/discounting, 1]\n",
    "        lb = [0, 0]\n",
    "        xopt, fopt = pso(obj, lb, ub)\n",
    "        max_val = -fopt\n",
    "        bk_m, theta_m = xopt\n",
    "        b_m = bk_m * theta_m\n",
    "        k_m = bk_m * (1-theta_m)\n",
    "        if t < T_R:\n",
    "            c_m = (1-tau_L)*(y(t, x) * (1-0.05)) + w - bk_m\n",
    "        else:\n",
    "            c_m = (1-tau_R)*y(t, x) + w + n/discounting - bk_m\n",
    "        return np.array([max_val, [c_m, b_m, k_m]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# wealth discretization \n",
    "w_grid_size = 100\n",
    "w_lower = 5\n",
    "w_upper = 20000\n",
    "# 401k amount discretization \n",
    "n_grid_size = 50\n",
    "n_lower = 5\n",
    "n_upper = 1000\n",
    "\n",
    "def powspace(start, stop, power, num):\n",
    "    start = np.power(start, 1/float(power))\n",
    "    stop = np.power(stop, 1/float(power))\n",
    "    return np.power( np.linspace(start, stop, num=num), power)\n",
    "\n",
    "# initialize the state discretization \n",
    "x_T = np.array([[w,n,e,s,0]   for w in powspace(w_lower, w_upper, 3, w_grid_size)\n",
    "                            for n in powspace(n_lower, n_upper, 3, n_grid_size)\n",
    "                            for s in [0,1]\n",
    "                            for e in [0,1]\n",
    "                            for A in [0,1]]).reshape((w_grid_size, n_grid_size, 2,2,2,5))\n",
    "\n",
    "xgrid = np.array([[w,n,e,s,A] for w in powspace(w_lower, w_upper, 3, w_grid_size)\n",
    "                            for n in powspace(n_lower, n_upper, 3, n_grid_size)\n",
    "                            for s in [0,1]\n",
    "                            for e in [0,1]\n",
    "                            for A in [0,1]]).reshape((w_grid_size, n_grid_size, 2,2,2,5))\n",
    "\n",
    "Vgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "cgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "bgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "kgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "\n",
    "# apply function to state space, need to reshape the matrix and shape it back to the size\n",
    "def applyFunToCalculateValue(fun, x = xgrid):\n",
    "    return np.array(list(map(fun, x.reshape((w_grid_size * n_grid_size * 2 * 2 * 2, 5))))).reshape((w_grid_size, n_grid_size, 2,2,2))\n",
    "\n",
    "Vgrid[:,:,:,:,:, T_max] = applyFunToCalculateValue(partial(R, a = [0,0,0]), x = x_T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time \n",
    "ws = xgrid[:,:,1,1,1,0].flatten()\n",
    "ns = xgrid[:,:,1,1,1,1].flatten()\n",
    "\n",
    "xs = xgrid.reshape((w_grid_size * n_grid_size * 2 * 2 * 2, 5))\n",
    "\n",
    "pool = Pool()\n",
    "\n",
    "for t in range(T_max-1, T_max-5, -1):\n",
    "    print(t)\n",
    "    cs = [[[np.vectorize(interp2d(ws, ns, Vgrid[:,:,s,e,A,t+1].flatten(),kind='cubic'))\n",
    "            for A in [0,1]] for e in [0,1]] for s in [0,1]]\n",
    "    f = partial(V, t = t, Vmodel = cs)\n",
    "    results = np.array(pool.map(f, xs))\n",
    "    \n",
    "    Vgrid[:,:,:,:,:,t] = results[:,0].reshape((w_grid_size,n_grid_size, 2,2,2))\n",
    "    plt.plot_surface(ws, ns, Vgrid[:,:,1,1,1,t])\n",
    "    plt.show()\n",
    "    cgrid[:,:,:,:,:,t] = np.array([r[0] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "    bgrid[:,:,:,:,:,t] = np.array([r[1] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "    kgrid[:,:,:,:,:,t] = np.array([r[2] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "pool.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Define the utility function\n",
    "def u(c):\n",
    "    gamma = 2\n",
    "    return (np.float_power(max(c-c_bar,0),1-gamma) - 1)/(1 - gamma)\n",
    "\n",
    "#Define the bequeath function, which is a function of wealth \n",
    "def uB(w):\n",
    "    B = 2\n",
    "    return B*u(w)\n",
    "\n",
    "#Define the earning function \n",
    "def y(t, x):\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return 0\n",
    "    else:\n",
    "        if t <= T_R:\n",
    "            return detEarning[t] * earningShock[int(s)] * e + (1-e)*5\n",
    "        else:\n",
    "            return detEarning[t]\n",
    "\n",
    "# Define the reward funtion\n",
    "def R(x, a):\n",
    "    c, b, k = a\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return uB(w+n)\n",
    "    else:\n",
    "        return u(c)\n",
    "\n",
    "# Define the transtiion of state (test)\n",
    "def transition(x, a, t):\n",
    "    '''\n",
    "        Input: x current state: (w, n, e, s, A) \n",
    "               a action taken: (c, b, k)\n",
    "        Output: the next possible states with corresponding probabilities\n",
    "    '''\n",
    "    c, b, k = a\n",
    "    w, n, s, e, A = x\n",
    "    \n",
    "    x_next = []\n",
    "    prob_next = []\n",
    "    # Agent is dead \n",
    "    if A == 0:\n",
    "        for s_next in [0, 1]:\n",
    "            x_next.append([0, 0, s_next, 0, 0])\n",
    "        return np.array(x_next), Ps[int(s)]\n",
    "    else:\n",
    "        # A = 1, agent is still alive and for the next period\n",
    "        Pat = [1-Pa[t], Pa[t]]\n",
    "        r_bond = r_f[int(s)]\n",
    "        for s_next in [0, 1]:\n",
    "            r_stock = r_m[int(s), s_next]\n",
    "            w_next =  b*(1+r_bond) + k*(1+r_stock)\n",
    "            if t < T_R:\n",
    "                # before retirement agents put 5% of income to 401k\n",
    "                n_next = (n+0.05*y(t,x))(1+r_stock)\n",
    "            else:\n",
    "                # after retirement calculate the annuity payment\n",
    "                N = np.sum(Pa[t:])\n",
    "                discounting = ((1+r_bar)**N - 1)/(r_bar*(1+r_bar)**N)\n",
    "                n_next = (n-n/discounting)*(1+r_stock)\n",
    "            for e_next in [0,1]:\n",
    "                for A_next in [0,1]:\n",
    "                    # Age reaches 65 or agent is dead directly results in unemployment\n",
    "                    if t > T_R or A_next == 0:\n",
    "                        x_next.append([w_next, n_next, s_next, 0, A_next])\n",
    "                    else:\n",
    "                        x_next.append([w_next, n_next, s_next, e_next, A_next])\n",
    "                    prob_next.append(Ps[int(s)][s_next] * Pat[A_next] * Pe[int(s),s_next,int(e),e_next])\n",
    "        return np.array(x_next), np.array(prob_next) \n",
    "    \n",
    "# Value function is a function of state and time t\n",
    "def V(x, t, Vmodel):\n",
    "    # Define the objective function as a function of action\n",
    "    w, n, s, e, A = x\n",
    "    if A == 0:\n",
    "        return np.array([R(x,[0,0,0]),[0,0,0]])\n",
    "    else: \n",
    "        N = np.sum(Pa[t:])\n",
    "        discounting = ((1+r_bar)**N - 1)/(r_bar*(1+r_bar)**N)\n",
    "        def obj(bkTheta):\n",
    "            bk,theta = bkTheta\n",
    "            b = bk * theta\n",
    "            k = bk * (1-theta)\n",
    "            if t < T_R:\n",
    "                c = (1-tau_L)*(y(t, x) * (1-0.05)) + w - bk\n",
    "            else:\n",
    "                c = (1-tau_R)*y(t, x) + w + n/discounting - bk\n",
    "            if c <= c_bar:\n",
    "                return 9999999999\n",
    "            a = (c,b,k)\n",
    "            x_next, prob_next = transition(x, a, t)\n",
    "            return -(R(x, a) + beta * np.dot(Vmodel[int(s)][int(e)][int(A)](x_next[:,0], x_next[:,1]), prob_next))\n",
    "\n",
    "        if t < T_R:\n",
    "            ub = [(1-tau_L)*(y(t, x) * (1-0.05)) + w, 1]\n",
    "        else:\n",
    "            ub = [(1-tau_R)*y(t, x) + w + n/discounting, 1]\n",
    "        lb = [0, 0]\n",
    "        xopt, fopt = pso(obj, lb, ub)\n",
    "        max_val = -fopt\n",
    "        bk_m, theta_m = xopt\n",
    "        b_m = bk_m * theta_m\n",
    "        k_m = bk_m * (1-theta_m)\n",
    "        if t < T_R:\n",
    "            c_m = (1-tau_L)*(y(t, x) * (1-0.05)) + w - bk_m\n",
    "        else:\n",
    "            c_m = (1-tau_R)*y(t, x) + w + n/discounting - bk_m\n",
    "        return np.array([max_val, [c_m, b_m, k_m]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "# wealth discretization \n",
    "w_grid_size = 100\n",
    "w_lower = 5\n",
    "w_upper = 20000\n",
    "# 401k amount discretization \n",
    "n_grid_size = 50\n",
    "n_lower = 5\n",
    "n_upper = 1000\n",
    "\n",
    "def powspace(start, stop, power, num):\n",
    "    start = np.power(start, 1/float(power))\n",
    "    stop = np.power(stop, 1/float(power))\n",
    "    return np.power( np.linspace(start, stop, num=num), power)\n",
    "\n",
    "# initialize the state discretization \n",
    "x_T = np.array([[w,n,e,s,0]   for w in powspace(w_lower, w_upper, 3, w_grid_size)\n",
    "                            for n in powspace(n_lower, n_upper, 3, n_grid_size)\n",
    "                            for s in [0,1]\n",
    "                            for e in [0,1]\n",
    "                            for A in [0,1]]).reshape((w_grid_size, n_grid_size, 2,2,2,5))\n",
    "\n",
    "xgrid = np.array([[w,n,e,s,A] for w in powspace(w_lower, w_upper, 3, w_grid_size)\n",
    "                            for n in powspace(n_lower, n_upper, 3, n_grid_size)\n",
    "                            for s in [0,1]\n",
    "                            for e in [0,1]\n",
    "                            for A in [0,1]]).reshape((w_grid_size, n_grid_size, 2,2,2,5))\n",
    "\n",
    "Vgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "cgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "bgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "kgrid = np.zeros((w_grid_size, n_grid_size, 2, 2, 2, T_max+1))\n",
    "\n",
    "# apply function to state space, need to reshape the matrix and shape it back to the size\n",
    "def applyFunToCalculateValue(fun, x = xgrid):\n",
    "    return np.array(list(map(fun, x.reshape((w_grid_size * n_grid_size * 2 * 2 * 2, 5))))).reshape((w_grid_size, n_grid_size, 2,2,2))\n",
    "\n",
    "Vgrid[:,:,:,:,:, T_max] = applyFunToCalculateValue(partial(R, a = [0,0,0]), x = x_T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time \n",
    "ws = xgrid[:,:,1,1,1,0].flatten()\n",
    "ns = xgrid[:,:,1,1,1,1].flatten()\n",
    "\n",
    "xs = xgrid.reshape((w_grid_size * n_grid_size * 2 * 2 * 2, 5))\n",
    "\n",
    "pool = Pool()\n",
    "\n",
    "for t in range(T_max-1, T_max-5, -1):\n",
    "    print(t)\n",
    "    cs = [[[np.vectorize(interp2d(ws, ns, Vgrid[:,:,s,e,A,t+1].flatten(),kind='cubic'))\n",
    "            for A in [0,1]] for e in [0,1]] for s in [0,1]]\n",
    "    f = partial(V, t = t, Vmodel = cs)\n",
    "    results = np.array(pool.map(f, xs))\n",
    "    \n",
    "    Vgrid[:,:,:,:,:,t] = results[:,0].reshape((w_grid_size,n_grid_size, 2,2,2))\n",
    "    plt.plot_surface(ws, ns, Vgrid[:,:,1,1,1,t])\n",
    "    plt.show()\n",
    "    cgrid[:,:,:,:,:,t] = np.array([r[0] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "    bgrid[:,:,:,:,:,t] = np.array([r[1] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "    kgrid[:,:,:,:,:,t] = np.array([r[2] for r in results[:,1]]).reshape((w_grid_size, n_grid_size,2,2,2))\n",
    "pool.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface(ws, ns, Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface(ws, ns, Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface(ws.reshape((w_grid_size, n_grid_size), ns.reshape((w_grid_size, n_grid_size), Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "ws.reshape((w_grid_size, n_grid_size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface(ws.reshape((w_grid_size, n_grid_size)), ns.reshape((w_grid_size, n_grid_size)), Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "Vgrid[:,:,1,1,1,t]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "Vgrid[:,:,1,1,1,t].shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface(x = ws.reshape((w_grid_size, n_grid_size)), y = ns.reshape((w_grid_size, n_grid_size)),z =  Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface(X = ws.reshape((w_grid_size, n_grid_size)), Y = ns.reshape((w_grid_size, n_grid_size)), =  Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "Axes3D.plot_surface(X = ws.reshape((w_grid_size, n_grid_size)), Y = ns.reshape((w_grid_size, n_grid_size)), Z=  Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = plt.figure()\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "ax.plot_surface(X = ws.reshape((w_grid_size, n_grid_size)), Y = ns.reshape((w_grid_size, n_grid_size)), Z=  Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = plt.figure(figsize = ][12, 8])\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "ax.plot_surface(X = ws.reshape((w_grid_size, n_grid_size)), Y = ns.reshape((w_grid_size, n_grid_size)), Z=  Vgrid[:,:,1,1,1,t])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = plt.figure(figsize = [12, 8])\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "ax.plot_surface(X = ws.reshape((w_grid_size, n_grid_size)), Y = ns.reshape((w_grid_size, n_grid_size)), Z=  Vgrid[:,:,1,1,1,t])"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
